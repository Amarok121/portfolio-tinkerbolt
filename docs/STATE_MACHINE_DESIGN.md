# State Machine System Design

## ğŸ“‹ ê°œìš”

TinkerB0ltì˜ ìƒíƒœ ë¨¸ì‹  ì‹œìŠ¤í…œì€ í”Œë ˆì´ì–´, ë™ë£Œ, ì  ìºë¦­í„°ì˜ í–‰ë™ì„ ì œì–´í•˜ëŠ” í•µì‹¬ ì•„í‚¤í…ì²˜ì…ë‹ˆë‹¤. State Machine Patternì„ ì ìš©í•˜ì—¬ ë³µì¡í•œ boolean í”Œë˜ê·¸ ê¸°ë°˜ ì‹œìŠ¤í…œì„ ê¹”ë”í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°ë¡œ ëŒ€ì²´í–ˆìŠµë‹ˆë‹¤.

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

### í•µì‹¬ êµ¬ì¡°

```
StateMachine (Manager)
â”œâ”€â”€ states: Array[Node]              # ë“±ë¡ëœ ëª¨ë“  ìƒíƒœ
â”œâ”€â”€ current_state: Node               # í˜„ì¬ í™œì„± ìƒíƒœ
â”œâ”€â”€ prev_state: Node                 # ì´ì „ ìƒíƒœ (íˆìŠ¤í† ë¦¬)
â””â”€â”€ State Classes                     # ê°œë³„ ìƒíƒœ í´ë˜ìŠ¤ë“¤
    â”œâ”€â”€ PlayerState (Base Class)
    â”‚   â”œâ”€â”€ init()                   # ìƒíƒœ ì´ˆê¸°í™”
    â”‚   â”œâ”€â”€ enter()                  # ìƒíƒœ ì§„ì…
    â”‚   â”œâ”€â”€ exit()                   # ìƒíƒœ ì¢…ë£Œ
    â”‚   â”œâ”€â”€ process(delta) -> Node   # í”„ë ˆì„ ì—…ë°ì´íŠ¸, ë‹¤ìŒ ìƒíƒœ ë°˜í™˜
    â”‚   â”œâ”€â”€ physics(delta) -> Node   # ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
    â”‚   â””â”€â”€ handle_input(event) -> Node  # ì…ë ¥ ì²˜ë¦¬
    â”œâ”€â”€ PlayerStateIdle
    â”œâ”€â”€ PlayerStateMoving
    â”œâ”€â”€ PlayerStateAttack
    â””â”€â”€ ...
```

### ì„¤ê³„ ì›ì¹™

1. **ë‹¨ì¼ ì±…ì„ ì›ì¹™**: ê° ìƒíƒœëŠ” í•˜ë‚˜ì˜ ëª…í™•í•œ í–‰ë™ë§Œ ë‹´ë‹¹
2. **ê°œë°©-íì‡„ ì›ì¹™**: ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ì´ ìƒˆ ìƒíƒœ ì¶”ê°€ ê°€ëŠ¥
3. **ë‹¤í˜•ì„±**: ëª¨ë“  ìƒíƒœê°€ ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
4. **ëŠìŠ¨í•œ ê²°í•©**: ìƒíƒœ ê°„ ì§ì ‘ ì°¸ì¡° ìµœì†Œí™”

## ğŸ”„ ìƒíƒœ ì „í™˜ ì‹œìŠ¤í…œ

### ì „í™˜ ë©”ì»¤ë‹ˆì¦˜

ìƒíƒœ ì „í™˜ì€ ê° ìƒíƒœì˜ ì—…ë°ì´íŠ¸ ë©”ì„œë“œì—ì„œ ë‹¤ìŒ ìƒíƒœë¥¼ ë°˜í™˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤:

```gdscript
# ì˜ˆì‹œ: PlayerStateIdle.process()
func process(_delta: float) -> Node:
    if input_direction != Vector2.ZERO:
        return get_moving_state()  # ë‹¤ìŒ ìƒíƒœ ë°˜í™˜
    return null  # í˜„ì¬ ìƒíƒœ ìœ ì§€
```

### ìƒíƒœ ì „í™˜ íë¦„

```
[Idle]
  â”œâ”€ ì´ë™ ì…ë ¥ â†’ [Moving]
  â”œâ”€ ê³µê²© ì…ë ¥ â†’ [Attack] â†’ ì™„ë£Œ â†’ [Idle]
  â””â”€ ëŒ€ì‹œ ì…ë ¥ â†’ [Dash] â†’ ì™„ë£Œ â†’ [Idle]
```

### ì „í™˜ ìš°ì„ ìˆœìœ„

1. **Damage/Stun** (ìµœê³  ìš°ì„ ìˆœìœ„)
2. **Attack States**
3. **Dash**
4. **Movement**
5. **Idle** (ê¸°ë³¸ ìƒíƒœ)

## ğŸ“¦ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­

### StateMachine í´ë˜ìŠ¤

**í•µì‹¬ ê¸°ëŠ¥:**
- ìƒíƒœ ë“±ë¡ ë° ê´€ë¦¬
- ìƒíƒœ ì „í™˜ ì²˜ë¦¬ (`change_state()`)
- í”„ë ˆì„ë³„/ë¬¼ë¦¬ë³„ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
- ì…ë ¥ ì´ë²¤íŠ¸ ì „ë‹¬

**ì£¼ìš” ë©”ì„œë“œ:**
```gdscript
func change_state(new_state: Node) -> void:
    if current_state:
        current_state.exit()  # ì´ì „ ìƒíƒœ ì¢…ë£Œ
    
    prev_state = current_state
    current_state = new_state
    current_state.enter()  # ìƒˆ ìƒíƒœ ì§„ì…
```

### PlayerState (ê¸°ë³¸ í´ë˜ìŠ¤)

**ì—­í• :**
- ëª¨ë“  ìƒíƒœì˜ ê³µí†µ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
- ê³µí†µ ê¸°ëŠ¥ ì œê³µ (í”Œë ˆì´ì–´ ì°¸ì¡°, ìƒíƒœ ë¨¸ì‹  ì°¸ì¡°)
- ê¸°ë³¸ ë™ì‘ êµ¬í˜„ (íƒ€ì´ë¨¸, ì• ë‹ˆë©”ì´ì…˜ ë“±)

**ì£¼ìš” ì†ì„±:**
- `player: player_movement` - ì œì–´ ëŒ€ìƒ í”Œë ˆì´ì–´
- `state_machine: Node` - ìƒíƒœ ë¨¸ì‹  ì°¸ì¡°

### êµ¬ì²´ì ì¸ ìƒíƒœ ì˜ˆì‹œ

#### PlayerStateIdle
- **ì±…ì„**: í”Œë ˆì´ì–´ê°€ ì•„ë¬´ ì…ë ¥ë„ í•˜ì§€ ì•ŠëŠ” ê¸°ë³¸ ìƒíƒœ
- **ì „í™˜ ì¡°ê±´**: ì…ë ¥ ê°ì§€ ì‹œ í•´ë‹¹ ìƒíƒœë¡œ ì „í™˜
- **íŠ¹ì§•**: ì¦‰ì‹œ ë‹¤ë¥¸ ìƒíƒœë¡œ ì „í™˜ ê°€ëŠ¥

#### PlayerStateAttack
- **ì±…ì„**: ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ë° íˆíŠ¸ë°•ìŠ¤ ê´€ë¦¬
- **ì „í™˜ ì¡°ê±´**: ê³µê²© íƒ€ì´ë¨¸ ì¢…ë£Œ ë˜ëŠ” ì—°ì† ê³µê²© ì…ë ¥
- **íŠ¹ì§•**: SkillManagerì™€ ì—°ë™í•˜ì—¬ ì‹¤ì œ ê³µê²© ì²˜ë¦¬

#### PlayerStateMoving
- **ì±…ì„**: í”Œë ˆì´ì–´ ì´ë™ ì²˜ë¦¬
- **ì „í™˜ ì¡°ê±´**: ì…ë ¥ ë°©í–¥ ë³€í™” ë˜ëŠ” ì •ì§€
- **íŠ¹ì§•**: ê±·ê¸°/ë‹¬ë¦¬ê¸° ëª¨ë“œ ì§€ì›

## ğŸ”— ì‹œìŠ¤í…œ ì—°ë™

### Animation Tree ì—°ë™

ê° ìƒíƒœëŠ” í•´ë‹¹í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì¡°ê±´ì„ ì„¤ì •í•©ë‹ˆë‹¤:

```gdscript
func enter() -> void:
    player.animation_tree.set("parameters/conditions/idle", true)
```

### Skill System ì—°ë™

ê³µê²© ìƒíƒœëŠ” SkillManagerë¥¼ í†µí•´ ì‹¤ì œ ê³µê²©ì„ ì‹¤í–‰í•©ë‹ˆë‹¤:

```gdscript
func enter() -> void:
    var mouse_position = player.get_global_mouse_position()
    attack_executed = skill_manager.execute_skill("Wrench_Attack", mouse_position)
```

### GlobalController ì—°ë™

í™œì„± ìœ ë‹› ê´€ë¦¬ì™€ ì—°ë™í•˜ì—¬ ë©€í‹°í”Œë ˆì´ì–´ ì§€ì›:

```gdscript
if GlobalController.active_unit != player:
    return  # ë¹„í™œì„± ìœ ë‹›ì€ ì²˜ë¦¬ ì•ˆí•¨
```

## ğŸ¯ ì£¼ìš” íŠ¹ì§•

### 1. ë™ì  ìƒíƒœ ìƒì„±

í•„ìš”í•œ ìƒíƒœê°€ ì”¬ì— ì—†ìœ¼ë©´ ëŸ°íƒ€ì„ì— ìƒì„±:

```gdscript
if not dash_state_exists:
    var dash_state = Node.new()
    dash_state.set_script(load("res://.../player_state_dash.gd"))
    add_child(dash_state)
    states.append(dash_state)
```

### 2. AI ëª¨ë“œ ì§€ì›

ìƒíƒœ ë¨¸ì‹ ì€ AI ì œì–´ì™€ í”Œë ˆì´ì–´ ì œì–´ë¥¼ ëª¨ë‘ ì§€ì›:

```gdscript
# AI ëª¨ë“œ: ì‹œë®¬ë ˆì´ì…˜ëœ ì…ë ¥ ì‚¬ìš©
if player.is_ai_controlled:
    input_vector = player.player_ai.get_simulated_input_vector()
```

### 3. í˜¸í™˜ì„± ëª¨ë“œ

ê¸°ì¡´ boolean ê¸°ë°˜ ì‹œìŠ¤í…œê³¼ ê³µì¡´ ê°€ëŠ¥:

```gdscript
@export var use_state_machine: bool = true
# ëŸ°íƒ€ì„ì— ì „í™˜ ê°€ëŠ¥
```

## ğŸ“Š ìƒíƒœ ë¨¸ì‹ ì˜ ì´ì 

1. **ê°€ë…ì„±**: ê° ìƒíƒœì˜ ë¡œì§ì´ ë¶„ë¦¬ë˜ì–´ ì´í•´í•˜ê¸° ì‰¬ì›€
2. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ìƒíƒœ ì¶”ê°€ê°€ ê°„ë‹¨í•¨ (`PlayerStateX` í´ë˜ìŠ¤ ìƒì„±)
3. **ë””ë²„ê¹…**: í˜„ì¬ ìƒíƒœë¥¼ ëª…í™•íˆ ì¶”ì  ê°€ëŠ¥
4. **ìœ ì§€ë³´ìˆ˜**: ìƒíƒœë³„ ë…ë¦½ì ì¸ ìˆ˜ì • ê°€ëŠ¥
5. **ì¬ì‚¬ìš©ì„±**: ìƒíƒœ í´ë˜ìŠ¤ë¥¼ ë‹¤ë¥¸ ì—”í‹°í‹°ì—ì„œ ì¬í™œìš© ê°€ëŠ¥

## ğŸ”„ ë™ë£Œ ìƒíƒœ ë¨¸ì‹ 

ë™ë£Œ ì‹œìŠ¤í…œë„ ë™ì¼í•œ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì§€ë§Œ, AI ì—°ë™ì´ ì¶”ê°€ë©ë‹ˆë‹¤:

```
CompanionStateMachine
â”œâ”€â”€ AI ëª¨ë“œ: CompanionAIê°€ ìƒíƒœ ì „í™˜ ê²°ì •
â”œâ”€â”€ í”Œë ˆì´ì–´ ì¡°ì‘ ëª¨ë“œ: ì‹¤ì œ ì…ë ¥ ì‚¬ìš©
â””â”€â”€ ìƒíƒœ ì „í™˜ì€ CompanionAIì˜ í–‰ë™ì— ë”°ë¼ ìë™ ê²°ì •
```

### ë™ë£Œ ì „ìš© ìƒíƒœ

- **CompanionStateFollowing**: í”Œë ˆì´ì–´ ì¶”ì 
- **CompanionStateCombat**: ì „íˆ¬ í–‰ë™
- **CompanionStateGuard**: ê²½ê³„ í–‰ë™

## ğŸ¨ í™•ì¥ ê°€ëŠ¥ì„±

### ìƒˆ ìƒíƒœ ì¶”ê°€ ë°©ë²•

1. `PlayerState`ë¥¼ ìƒì†í•˜ëŠ” ìƒˆ í´ë˜ìŠ¤ ìƒì„±
2. í•„ìš”í•œ ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ (`enter()`, `process()`, `handle_input()` ë“±)
3. ì”¬ì— ë…¸ë“œë¡œ ì¶”ê°€í•˜ê±°ë‚˜ ëŸ°íƒ€ì„ì— ë™ì  ìƒì„±
4. ìƒíƒœ ë¨¸ì‹ ì´ ìë™ìœ¼ë¡œ ì¸ì‹

### ì˜ˆì‹œ: PlayerStateJump ì¶”ê°€

```gdscript
class_name PlayerStateJump extends PlayerState

func enter() -> void:
    player.jump()
    
func process(_delta: float) -> Node:
    if player.is_on_floor():
        return get_idle_state()
    return null
```

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### ì—…ë°ì´íŠ¸ ìµœì í™”

- ë¹„í™œì„± ìœ ë‹›ì˜ ìƒíƒœ ë¨¸ì‹ ì€ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ìŠ¤í‚µ
- ìƒíƒœ ì „í™˜ì€ í•„ìš”í•  ë•Œë§Œ ë°œìƒ
- íƒ€ì´ë¨¸ ê¸°ë°˜ ìƒíƒœ ì „í™˜ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ì²´í¬ ìµœì†Œí™”

### ë©”ëª¨ë¦¬ ê´€ë¦¬

- ìƒíƒœ ê°ì²´ëŠ” ì”¬ì˜ ì¼ë¶€ë¡œ ê´€ë¦¬ (ìë™ í•´ì œ)
- ìƒíƒœ ì „í™˜ ì‹œ ì´ì „ ìƒíƒœì˜ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (`exit()` ë©”ì„œë“œ)

## ğŸ” ë””ë²„ê¹… ë° ëª¨ë‹ˆí„°ë§

### ìƒíƒœ ì¶”ì 

```gdscript
func get_state_info() -> Dictionary:
    return {
        "current_state": current_state.get_script().get_global_name(),
        "previous_state": prev_state.get_script().get_global_name(),
        "total_states": states.size()
    }
```

### ë””ë²„ê·¸ ì¶œë ¥

ìƒíƒœ ì „í™˜ ì‹œ ìë™ìœ¼ë¡œ ë””ë²„ê·¸ ë¡œê·¸ ì¶œë ¥ (ì„ íƒì ):
- ì´ì „ ìƒíƒœ ì´ë¦„
- ìƒˆ ìƒíƒœ ì´ë¦„
- ì „í™˜ ì‹œì 

---

**ì´ ìƒíƒœ ë¨¸ì‹  ì‹œìŠ¤í…œì€ ê²Œì„ì˜ ëª¨ë“  ìºë¦­í„° ì œì–´ì˜ ê¸°ë°˜ì´ ë˜ë©°, í™•ì¥ ê°€ëŠ¥í•˜ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ êµ¬ì¡°ë¥¼ ì œê³µí•©ë‹ˆë‹¤.**

